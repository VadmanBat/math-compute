#include "nrcki/scheme.h"

#include "blocks/dynamic/integrator.hpp"
#include "blocks/dynamic/inertial.hpp"
#include "blocks/dynamic/inertial-differential.hpp"
#include "blocks/dynamic/oscillatory.hpp"
#include "blocks/dynamic/step-delay.hpp"

namespace nrcki {
/**
 * Добавляет интегрирующее звено (Integrator) на схему.
 * Дифференциальное уравнение: dy/dt = k * x(t)
 * Передаточная функция: W(s) = k / s
 *
 * Применение:
 * <ul>
 *   <li>накопление величины (интеграл от входного сигнала);</li>
 *   <li>преобразование скорости в перемещение;</li>
 *   <li>создание запаздывающих звеньев в комбинации с другими элементами;</li>
 *   <li>моделирование ёмкостных элементов (гидравлика, электротехника).</li>
 * </ul>
 *
 * @param k коэффициент усиления
 * @param y0 начальное значение выходного сигнала при t=0
 */
void Scheme::addIntegrator(double k, double y0) {
    ++blocks_count;
    blocks.push_back(std::make_unique<Integrator>(*this, k, y0));
}

/**
 * Добавляет инерционное звено 1-го порядка (Inertial) на схему.
 * Дифференциальное уравнение: T * dy/dt + y = k * u(t)
 * Передаточная функция: W(s) = k / (T*s + 1)
 *
 * Применение:
 * <ul>
 *   <li>моделирование систем с тепловой инерцией (нагреватели);</li>
 *   <li>фильтрация высокочастотных шумов;</li>
 *   <li>аппроксимация динамики двигателей и механических систем;</li>
 *   <li>имитация "плавающего" поведения (гидравлические системы).</li>
 * </ul>
 *
 * @param k коэффициент усиления (установившееся значение)
 * @param T постоянная времени [сек] (характеризует инерционность)
 * @param y0 начальное значение выходного сигнала при t=0
 */
void Scheme::addInertial(double k, double T, double y0) {
    ++blocks_count;
    blocks.push_back(std::make_unique<Inertial>(*this, k, T, y0));
}

/**
 * Добавляет инерционно-дифференцирующее звено (Inertial-Differential) на схему.
 * Дифференциальное уравнение: y = k * (T * dx/dt + x(t))
 * Передаточная функция: W(s) = k * (T*s + 1)
 *
 * Применение:
 * <ul>
 *   <li>выделение производной с фильтрацией высокочастотных шумов;</li>
 *   <li>формирование упреждающих сигналов в системах управления;</li>
 *   <li>компенсация фазовых запаздываний;</li>
 *   <li>моделирование датчиков скорости (тахогенераторы).</li>
 * </ul>
 *
 * @param k коэффициент усиления
 * @param T постоянная времени [сек] (определяет степень дифференцирования)
 * @param y0 начальное значение выходного сигнала при t=0
 */
void Scheme::addInertialDifferential(double k, double T, double y0) {
    ++blocks_count;
    blocks.push_back(std::make_unique<InertialDifferential>(*this, k, T, y0));
}

/**
 * Добавляет колебательное звено (Oscillatory) на схему.
 * Дифференциальное уравнение:
 *   T² * d²y/dt² + 2*b*T * dy/dt + y = k * u(t)
 * Передаточная функция:
 *   W(s) = k / (T²*s² + 2*b*T*s + 1)
 *
 * Применение:
 * <ul>
 *   <li>моделирование пружинно-демпферных систем;</li>
 *   <li>анализ вибраций и резонансных явлений;</li>
 *   <li>имитация колебаний исполнительного механизма;</li>
 *   <li>исследование устойчивости систем управления.</li>
 * </ul>
 *
 * @param k коэффициент усиления
 * @param T постоянная времени [сек] (определяет частоту собственных колебаний)
 * @param b коэффициент демпфирования (0 < b < 1 - колебательный режим)
 * @param y0 начальное значение выходного сигнала при t=0
 * @param dy0 начальная скорость изменения выходного сигнала при t=0
 */
void Scheme::addOscillatory(double k, double T, double b, double y0, double dy0) {
    ++blocks_count;
    blocks.push_back(std::make_unique<Oscillatory>(*this, k, T, b, y0, dy0));
}

/**
 * Добавляет блок задержки на один шаг интегрирования (Step Delay) на схему.
 * Выходной сигнал равен входному сигналу на ПРЕДЫДУЩЕМ шаге интегрирования:
 *   y(t) = x(t - Δt)
 *
 * Применение:
 * <ul>
 *   <li>имитация цифровых систем с задержкой выборки;</li>
 *   <li>создание простых линий задержки;</li>
 *   <li>предотвращение алгебраических петель в схеме;</li>
 *   <li>моделирование запаздывания в дискретных системах;</li>
 *   <li>реализация простых цифровых фильтров (например, разностных уравнений).</li>
 * </ul>
 *
 * При t=0 возвращает начальное значение y0.
 *
 * @param y0 значение выходного сигнала до первого шага интегрирования
 */
void Scheme::addStepDelay(double y0) {
    ++blocks_count;
    blocks.push_back(std::make_unique<StepDelay>(*this, y0));
}
}